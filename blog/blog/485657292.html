<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>PHP正则表达式及preg_replace函数的应用</title><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- top1 -->
<ins class="adsbygoogle"
     style="display:inline-block;width:728px;height:90px"
     data-ad-client="ca-pub-3347102627476643"
     data-ad-slot="2352128818"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></head><body><h1>PHP正则表达式及preg_replace函数的应用</h1><div><p><strong><span style="color: #000000; font-size: 24px;">一、PHP正则表达式</span></strong></p>
<p><span style="font-size: 16px;">正则表达式的形式一般如下：&nbsp;&nbsp;</span><br /><span style="font-size: 16px;">　　/love/&nbsp;&nbsp;</span><br /><span style="font-size: 16px;">　　其中位于“/”定界符之间的部分就是将要在目标对象中进行匹配的模式。用户只要把希望查找匹配对象的模式内容放入“/”定界符之间即可。为了能够使用户更加灵活的定制模式内容，正则表达式提供了专门的“元字符”。所谓元字符就是指那些在正则表达式中具有特殊意义的专用字符，可以用来规定其前导字符（即位于元字符前面的字符）在目标对象中的出现模式。&nbsp;&nbsp;</span><br /><span style="font-size: 16px;">　　较为常用的元字符包括： “+”， “*”，以及 “?”。其中，“+”元字符规定其前导字符必须在目标对象中连续出现一次或多次，“*”元字符规定其前导字符必须在目标对象中出现零次或连续多次，而“?”元字符规定其前导对象必须在目标对象中连续出现零次或一次。&nbsp;&nbsp;</span></p>
<p>&nbsp;<strong><span style="font-size: 16px;">(pattern) </span></strong>匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 '\(' 或 '\)'。 </p>
<p>&nbsp;&nbsp;&nbsp;<strong><span style="font-size: 16px;">(?:pattern)</span></strong> 匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行<a style="color: #000000;" title="存储" href="http://storage.it168.com/" target="_blank">存储</a>供以后使用。这在使用 &quot;或&quot; 字符 (|) 来组合一个模式的各个部分是很有用。例如， 'industr(?:y|ies) 就是一个比 'industry|industries' 更简略的表达式。</p>
<p>&nbsp;&nbsp;&nbsp;<strong><span style="font-size: 16px;">(?=pattern)</span></strong>正向预查，在任何匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，'Windows (?=95|98|NT|2000)' 能匹配 &quot;Windows 2000&quot; 中的 &quot;Windows&quot; ，但不能匹配 &quot;Windows 3.1&quot; 中的 &quot;Windows&quot;。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</p>
<p>&nbsp;&nbsp;<strong><span style="font-size: 16px;">&nbsp; (?!pattern)</span></strong> 负向预查，在任何不匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如'Windows (?!95|98|NT|2000)' 能匹配 &quot;Windows 3.1&quot; 中的 &quot;Windows&quot;，但不能匹配 &quot;Windows 2000&quot; 中的 &quot;Windows&quot;。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始</p>
<p><br /><span style="font-size: 16px;">　　下面，就让我们来看一下正则表达式元字符的具体应用。&nbsp;&nbsp;</span><br /><span style="font-size: 16px;">　　/fo+/&nbsp;&nbsp;</span><br /><span style="font-size: 16px;">　　因为上述正则表达式中包含“+”元字符，表示可以与目标对象中的 “fool”, “fo”, 或者 “football”等在字母f后面连续出现一个或多个字母o的字符串相匹配。&nbsp;&nbsp;</span><br /><span style="font-size: 16px;">　　/eg*/&nbsp;&nbsp;</span><br /><span style="font-size: 16px;">　　因为上述正则表达式中包含“*”元字符，表示可以与目标对象中的 “easy”, “ego”, 或者 “egg”等在字母e后面连续出现零个或多个字母g的字符串相匹配。&nbsp;&nbsp;</span><br /><span style="font-size: 16px;">　　/Wil?/&nbsp;&nbsp;</span><br /><span style="font-size: 16px;">　　因为上述正则表达式中包含“？”元字符，表示可以与目标对象中的 “Win”, 或者 “Wilson”,等在字母i后面连续出现零个或一个字母l的字符串相匹配。&nbsp;&nbsp;</span><br /><span style="font-size: 16px;">　　除了元字符之外，用户还可以精确指定模式在匹配对象中出现的频率。例如，&nbsp;&nbsp;</span><br /><span style="font-size: 16px;">　　/jim{2,6}/&nbsp;&nbsp;</span><br /><span style="font-size: 16px;">　　上述正则表达式规定字符m可以在匹配对象中连续出现2-6次，因此，上述正则表达式可以同jimmy或jimmmmmy等字符串相匹配。&nbsp;&nbsp;</span><br /><span style="font-size: 16px;">　　在对如何使用正则表达式有了初步了解之后，我们来看一下其它几个重要的元字符的使用方式。&nbsp;&nbsp;</span><br />　　<strong><span style="font-size: 16px;">\s：用于匹配单个空格符，包括tab键和换行符；&nbsp;&nbsp;</span><br /><span style="font-size: 16px;">　　\S：用于匹配除单个空格符之外的所有字符；&nbsp;&nbsp;</span><br /><span style="font-size: 16px;">　　\d：用于匹配从0到9的数字；&nbsp;&nbsp;</span><br /><span style="font-size: 16px;">　　\w：用于匹配字母，数字或下划线字符；&nbsp;&nbsp;</span><br /><span style="font-size: 16px;">　　\W：用于匹配所有与\w不匹配的字符；&nbsp;&nbsp;</span><br /><span style="font-size: 16px;">　　. ：用于匹配除换行符之外的所有字符。</span></strong><span style="font-size: 16px;">&nbsp;&nbsp;</span><br />　　<span style="font-size: 16px;">（说明：我们可以把\s和\S以及\w和\W看作互为逆运算）&nbsp;&nbsp;</span><br /><span style="font-size: 16px;">　　下面，我们就通过实例看一下如何在正则表达式中使用上述元字符。&nbsp;&nbsp;</span><br /><span style="font-size: 16px;">　　/\s+/&nbsp;&nbsp;</span><br /><span style="font-size: 16px;">　　上述正则表达式可以用于匹配目标对象中的一个或多个空格字符。&nbsp;&nbsp;</span><br /><span style="font-size: 16px;">　　/\d000/&nbsp;&nbsp;</span><br /><span style="font-size: 16px;">　　如果我们手中有一份复杂的财务报表，那么我们可以通过上述正则表达式轻而易举的查找到所有总额达千元的款项。&nbsp;&nbsp;</span><br /><span style="font-size: 16px;">　　除了我们以上所介绍的元字符之外，正则表达式中还具有另外一种较为独特的专用字符，即定位符。定位符用于规定匹配模式在目标对象中的出现位置。&nbsp;&nbsp;</span><br /><span style="font-size: 16px;">　　较为常用的定位符包括： “^”, “$”, “\b” 以及 “\B”。其中，“^”定位符规定匹配模式必须出现在目标字符串的开头，“$”定位符规定匹配模式必须出现在目标对象的结尾，\b定位符规定匹配模式必须出现在目标字符串的开头或结尾的两个边界之一，而“\B”定位符则规定匹配对象必须位于目标字符串的开头和结尾两个边界之内，即匹配对象既不能作为目标字符串的开头，也不能作为目标字符串的结尾。同样，我们也可以把“^”和“$”以及“\b”和“\B”看作是互为逆运算的两组定位符。举例来说：&nbsp;&nbsp;</span><br /><span style="font-size: 16px;">　　/^hell/&nbsp;&nbsp;</span><br /><span style="font-size: 16px;">　　因为上述正则表达式中包含“^”定位符，所以可以与目标对象中以 “hell”, “hello”或 “hellhound”开头的字符串相匹配。&nbsp;&nbsp;</span><br /><span style="font-size: 16px;">　　/ar$/&nbsp;&nbsp;</span><br /><span style="font-size: 16px;">　　因为上述正则表达式中包含“$”定位符，所以可以与目标对象中以 “car”, “bar”或 “ar” 结尾的字符串相匹配。&nbsp;&nbsp;</span><br /><span style="font-size: 16px;">　　/\bbom/&nbsp;&nbsp;</span><br /><span style="font-size: 16px;">　　因为上述正则表达式模式以“\b”定位符开头，所以可以与目标对象中以 “bomb”, 或 “bom”开头的字符串相匹配。&nbsp;&nbsp;</span><br /><span style="font-size: 16px;">　　/man\b/&nbsp;&nbsp;</span><br /><span style="font-size: 16px;">　　因为上述正则表达式模式以“\b”定位符结尾，所以可以与目标对象中以 “human”, “woman”或 “man”结尾的字符串相匹配。&nbsp;&nbsp;</span><br /><span style="font-size: 16px;">　　为了能够方便用户更加灵活的设定匹配模式，正则表达式允许使用者在匹配模式中指定某一个范围而不局限于具体的字符。例如：&nbsp;&nbsp;</span><br /><span style="font-size: 16px;">　　/[A-Z]/&nbsp;&nbsp;</span><br /><span style="font-size: 16px;">　　上述正则表达式将会与从A到Z范围内任何一个大写字母相匹配。&nbsp;&nbsp;</span><br /><span style="font-size: 16px;">　　/[a-z]/&nbsp;&nbsp;</span><br /><span style="font-size: 16px;">　　上述正则表达式将会与从a到z范围内任何一个小写字母相匹配。&nbsp;&nbsp;</span><br /><span style="font-size: 16px;">　　/[0-9]/&nbsp;&nbsp;</span><br /><span style="font-size: 16px;">　　上述正则表达式将会与从0到9范围内任何一个数字相匹配。&nbsp;&nbsp;</span><br /><span style="font-size: 16px;">　　/([a-z][A-Z][0-9])+/&nbsp;&nbsp;</span><br /><span style="font-size: 16px;">　　上述正则表达式将会与任何由字母和数字组成的字符串，如 “aB0” 等相匹配。这里需要提醒用户注意的一点就是可以在正则表达式中使用 “()” 把字符串组合在一起。“()”符号包含的内容必须同时出现在目标对象中。因此，上述正则表达式将无法与诸如 “abc”等的字符串匹配，因为“abc”中的最后一个字符为字母而非数字。&nbsp;&nbsp;</span><br /><span style="font-size: 16px;">　　如果我们希望在正则表达式中实现类似编程逻辑中的“或”运算，在多个不同的模式中任选一个进行匹配的话，可以使用管道符 “|”。例如：&nbsp;&nbsp;</span><br /><span style="font-size: 16px;">　　/to|too|2/&nbsp;&nbsp;</span><br /><span style="font-size: 16px;">　　上述正则表达式将会与目标对象中的 “to”, “too”, 或 “2” 相匹配。&nbsp;&nbsp;</span><br /><span style="font-size: 16px;">　　正则表达式中还有一个较为常用的运算符，即否定符 “[^]”。与我们前文所介绍的定位符 “^” 不同，否定符 “[^]”规定目标对象中不能存在模式中所规定的字符串。例如：&nbsp;&nbsp;</span><br /><span style="font-size: 16px;">　　/[^A-C]/&nbsp;&nbsp;</span><br /><span style="font-size: 16px;">　　上述字符串将会与目标对象中除A，B，和C之外的任何字符相匹配。一般来说，当“^”出现在 “[]”内时就被视做否定运算符；而当“^”位于“[]”之外，或没有“[]”时，则应当被视做定位符。&nbsp;&nbsp;</span><br /><span style="font-size: 16px;">　　最后，当用户需要在正则表达式的模式中加入元字符，并查找其匹配对象时，可以使用转义符“\”。例如：&nbsp;&nbsp;</span><br /><span style="font-size: 16px;">　　/Th\*/&nbsp;&nbsp;</span><br /><span style="font-size: 16px;">　　上述正则表达式将会与目标对象中的“Th*”而非“The”等相匹配。</span><br /><strong><span style="font-size: 24px;">二、修饰符</span></strong></p>
<p>&nbsp; 在正则表达式里面的修饰符可以改变正则的很多特性，使得正则表达式更加适合你的需要（注意：修饰符对于大小写是敏感的，这意味着 &quot;e &quot;并不等于 &quot;E &quot;）。正则表达式里面的修饰符如下： &nbsp; <br /><strong><span style="font-size: 18px;">i</span></strong>&nbsp; ：如果在修饰符中加上 &quot;i &quot;，则正则将会取消大小写敏感性，即 &quot;a &quot;和 &quot;A &quot; &nbsp; 是一样的。 &nbsp; <br /><strong><span style="font-size: 18px;">m</span></strong>：默认的正则开始 &quot;^ &quot;和结束 &quot;$ &quot;只是对于正则字符串如果在修饰符中加上 &quot;m &quot;，那么开始和结束将会指字符串的每一行：每一行的开头就是 &quot;^ &quot;，结尾就是 &quot;$ &quot;。 &nbsp; <br /><strong><span style="font-size: 18px;">s</span></strong>：如果在修饰符中加入 &quot;s &quot;，那么默认的 &quot;. &quot;代表除了换行符以外的任何字符将会变成任意字符，也就是包括换行符！ &nbsp; <br /><strong><span style="font-size: 18px;">x</span></strong>：如果加上该修饰符，表达式中的空白字符将会被忽略，除非它已经被转义。 &nbsp; <br /><strong><span style="font-size: 18px;">e</span></strong>：本修饰符仅仅对于replacement有用，代表在replacement中作为PHP代码。 &nbsp; <br /><strong><span style="font-size: 18px;">A</span></strong>：如果使用这个修饰符，那么表达式必须是匹配的字符串中的开头部分。比如说 &quot;/a/A &quot;匹配 &quot;abcd &quot;。 &nbsp; <br /><strong><span style="font-size: 18px;">E</span></strong>：与 &quot;m &quot;相反，如果使用这个修饰符，那么 &quot;$ &quot;将匹配绝对字符串的结尾，而不是换行符前面，默认就打开了这个模式。 &nbsp; <br /><strong><span style="font-size: 18px;">U</span></strong>：和问号的作用差不多，用于设置 &quot;贪婪模式 &quot;。</p>
<p><strong><span style="font-size: 24px;">三、分隔符</span></strong></p><strong><span style="font-size: 24px;">
<p><span style="font-size: 16px;">一个正则表达式，分为三个部分：<span style="color: #ff0000;">分隔符，表达式和修饰符</span>。</span></p>
<p><span style="font-size: 16px;"><span style="color: #ff0000;">分隔符可以是除了特殊字符以外的任何字符（比如&quot;/ !&quot;等等），常用的分隔符是&quot;/&quot;、&quot;#&quot;、&quot;|&quot;。</span>表达式由一些特殊字符（特殊字符详见下面）和非特殊的字符串组成，比如&quot;[a-z0-9_-]+@[a-z0-9_-.]+&quot;可以匹配一个简单的电子邮件字符串。修饰符是用来开启或者关闭某种功能/模式。</span></p></span></strong>
<p><strong><span style="color: #ff0000; font-size: 16px;">任何非字母，数字和\的字符都可以当做delimiter，好处，估计是可以不和expression里面的字符冲突，比如，如果里面有一个/，那么就用#好了</span></strong></p>
<p><strong><span style="font-size: 24px;">四、preg_replace函数实例（经验证）</span></strong></p>
<p><span style="font-size: 16px;">$string = &quot;April 15, 2003&quot;;</span><br /><span style="font-size: 16px;">$pattern = &quot;/(\w+) (\d+), (\d+)/i&quot;;</span><br /><span style="font-size: 16px;">$replacement = &quot;$1,$3&quot;;</span><br /><span style="font-size: 16px;">$ss = preg_replace($pattern, $replacement, $string);</span><br /><span style="font-size: 16px;">echo $ss;</span></p>
<p><strong><span style="font-size: 16px;">输出：April,2003</span></strong></p>
<p><span style="font-size: 16px;">$patterns = array (&quot;/(19|20)(\d{2})-(\d{1,2})-(\d{1,2})/&quot;,</span><br /><span style="font-size: 16px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;/^\s*{(\w+)}\s*=/&quot;);</span><br /><span style="font-size: 16px;">$replace = array (&quot;$3/$4/$1$2&quot;, &quot;$$1 =&quot;);</span><br /><span style="font-size: 16px;">echo preg_replace ($patterns, $replace, &quot;{startDate} = 1999-5-27&quot;);</span></p>
<p><span style="font-size: 16px;">输出：$startDate = 5/27/1999</span><br /><span style="font-size: 16px;">$string = &quot;The quick brown fox jumped over the lazy dog.&quot;;</span><br /><span style="font-size: 16px;">$patterns[0] = &quot;/quick/&quot;;</span><br /><span style="font-size: 16px;">$patterns[1] = &quot;/brown/&quot;;</span><br /><span style="font-size: 16px;">$patterns[2] = &quot;/fox/&quot;;</span><br /><span style="font-size: 16px;">$replacements[2] = &quot;bear&quot;;</span><br /><span style="font-size: 16px;">$replacements[1] = &quot;black&quot;;</span><br /><span style="font-size: 16px;">$replacements[0] = &quot;slow&quot;;</span><br /><span style="font-size: 16px;">echo preg_replace($patterns, $replacements, $string);</span></p>
<p><span style="font-size: 16px;">输出：The bear black slow jumped over the lazy dog.</span><br /><strong><span style="font-size: 24px;">五、贪婪模式</span></strong></p>
<p><span style="font-size: 16px;">什么是 &quot;贪婪模式 &quot;呢？ &nbsp;</span><br /><span style="font-size: 16px;">比如我们要匹配以字母 &quot;a &quot;开头字母 &quot;b &quot;结尾的字符串，但是需要匹配的字符串在 &quot;a &quot;后面含有很多个 &quot;b &quot;，比如 &quot;a &nbsp; bbbbbbbbbbbbbbbbb &quot;，那正则表达式是会匹配第一个 &quot;b &quot;还是最后一个 &quot;b &quot;呢？如果你使用了贪婪模式，那么会匹配到最后一个 &quot;b &quot;，反之只是匹配到第一个 &quot;b &quot;。 &nbsp;</span><br /><span style="font-size: 16px;">&nbsp; &nbsp; &nbsp; &nbsp; 使用贪婪模式的表达式如下： &nbsp;</span><br /><span style="font-size: 16px;">/a.+?b/ &nbsp;</span><br /><span style="font-size: 16px;">/a.+b/U &nbsp;</span><br /><span style="font-size: 16px;">不使用贪婪模式的如下： &nbsp;</span><br /><span style="font-size: 16px;">/a.+b/&nbsp;&nbsp;</span><br /></p></div></body></html>