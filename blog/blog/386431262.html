<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>linux shell 中&amp;#34;2&amp;#62;&amp;1&amp;#34;含义</title><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- top1 -->
<ins class="adsbygoogle"
     style="display:inline-block;width:728px;height:90px"
     data-ad-client="ca-pub-3347102627476643"
     data-ad-slot="2352128818"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></head><body><h1>linux shell 中&amp;#34;2&amp;#62;&amp;1&amp;#34;含义</h1><div><p><span style="FONT-SIZE: 16px">&nbsp;linux shell 中"2&gt;&amp;1"含义</span><br><span style="FONT-SIZE: 16px">脚本是:</span><br><span style="FONT-SIZE: 16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nohup /mnt/Nand3/H2000G&nbsp; &gt;/dev/null&nbsp; 2&gt;&amp;1&nbsp; &amp;</span><br><span style="FONT-SIZE: 16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对于&amp; 1 更准确的说应该是文件描述符 1,而1 一般代表的就是STDOUT_FILENO,实际上这个操作就是一个dup2(2)调用.他标准输出到all_result ,然后复制标准输出到文件描述符2(STDERR_FILENO),其后果就是文件描述符1和2指向同一个文件表项,也可以说错误的输出被合并了.其中0 表示键盘输入 1表示屏幕输出 2表示错误输出.把标准出错重定向到标准输出,然后扔到/DEV/NULL下面去。通俗的说，就是把所有标准输出和标准出错都扔到垃圾桶里面。</span><br><span style="FONT-SIZE: 16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; command &gt;out.file&nbsp; 2&gt;&amp;1 &amp;</span><br><span style="FONT-SIZE: 16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; command &gt;out.file是将command的输出重定向到out.file文件，即输出内容不打印到屏幕上，而是输出到out.file文件中。 2&gt;&amp;1 是将标准出错重定向到标准输出，这里的标准输出已经重定向到了out.file文件，即将标准出错也输出到out.file文件中。最后一个&amp; ， 是让该命令在后台执行。</span><br><span style="FONT-SIZE: 16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><br><span style="FONT-SIZE: 16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 试想2&gt;1代表什么，2与&gt;结合代表错误重定向，而1则代表错误重定向到一个文件1，而不代表标准输出；</span><br><span style="FONT-SIZE: 16px">换成2&gt;&amp;1，&amp;与1结合就代表标准输出了，就变成错误重定向到标准输出.</span></p>
<p><span style="FONT-SIZE: 16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 你可以用</span><br><span style="FONT-SIZE: 16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ls 2&gt;1测试一下，不会报没有2文件的错误，但会输出一个空的文件1；</span><br><span style="FONT-SIZE: 16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ls xxx 2&gt;1测试，没有xxx这个文件的错误输出到了1中；</span><br><span style="FONT-SIZE: 16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ls xxx 2&gt;&amp;1测试，不会生成1这个文件了，不过错误跑到标准输出了；</span><br><span style="FONT-SIZE: 16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ls xxx &gt;out.txt 2&gt;&amp;1, 实际上可换成 ls xxx 1&gt;out.txt 2&gt;&amp;1；重定向符号&gt;默认是1,错误和输出都传到out.txt了。</span><br><span style="FONT-SIZE: 16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 为何2&gt;&amp;1要写在后面？</span><br><span style="FONT-SIZE: 16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; command &gt; file 2&gt;&amp;1</span><br><span style="FONT-SIZE: 16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 首先是command &gt; file将标准输出重定向到file中， 2&gt;&amp;1 是标准错误拷贝了标准输出的行为，也就是同样被重定向到file中，最终结果就是标准输出和错误都被重定向到file中。</span><br><span style="FONT-SIZE: 16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; command 2&gt;&amp;1 &gt;file</span><br><span style="FONT-SIZE: 16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&gt;&amp;1 标准错误拷贝了标准输出的行为，但此时标准输出还是在终端。&gt;file 后输出才被重定向到file，但标准错误仍然保持在终端。</span></p>
<p><span style="FONT-SIZE: 16px">用strace可以看到：</span><br><span style="FONT-SIZE: 16px">1. command &gt; file 2&gt;&amp;1</span><br><span style="FONT-SIZE: 16px">这个命令中实现重定向的关键系统调用序列是：</span><br><span style="FONT-SIZE: 16px">open(file) == 3</span><br><span style="FONT-SIZE: 16px">dup2(3,1)</span><br><span style="FONT-SIZE: 16px">dup2(1,2)</span></p>
<p><span style="FONT-SIZE: 16px">2. command 2&gt;&amp;1 &gt;file</span><br><span style="FONT-SIZE: 16px">这个命令中实现重定向的关键系统调用序列是：</span><br><span style="FONT-SIZE: 16px">dup2(1,2)</span><br><span style="FONT-SIZE: 16px">open(file) == 3</span><br><span style="FONT-SIZE: 16px">dup2(3,1)&nbsp; </span></p>
<p><br>本文来自CSDN博客，转载请标明出处：<a href="http://blog.csdn.net/zhongteng/archive/2008/09/24/2973286.aspx">http://blog.csdn.net/zhongteng/archive/2008/09/24/2973286.aspx</a></p></div></body></html>